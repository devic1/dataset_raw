EX.NO: 1(a)(i)
DATE: 19/07/23
IMPLEMENTATION OF CLASSICAL SYMMETRIC ENCRYPTION TECHNIQUES
SUBSTITUTION CIPHERS - IMPLEMENTATION OF CAESAR CIPHER

AIM:
To implement Caesar Cipher substitution technique using c++.
ALGORITHM:
1. Start
2. Define the 'encrypt' function:
- Parameters: 'string text' and 'int s'.
- Initialize an empty string 'result'.

3. Loop through each character of 'text':
- Use a 'for' loop to iterate through each character of 'text'.

4. Check if the character is uppercase or lowercase:
- Use 'isupper()' to check for uppercase characters.
- If uppercase:
- Add 's' to ASCII value.
- Normalize using modulo 26.
- Add 65 to convert back to uppercase ASCII.
- If lowercase:
- Add 's' to ASCII value.
- Normalize using modulo 26 with 'a' as base.

5. Append the encrypted character to 'result':
- Add the character to 'result'.

6. Define the 'main' function:
- Declare 'text' and 's' variables.
- Prompt user for plain text and shift value.
- Print plain text and shift value.
- Call 'encrypt' with input text and shift value.
- Print the resulting cipher text.
7. Stop

PROGRAM:
 #include <iostream>
using namespace std;
string encrypt (string text, int s)
{
    string result = "";
	for (int i = 0; i < text.length(); i++) {
		if (isupper(text[i]))
			result += char(int(text[i] + s - 65) % 26 + 65);

		else
			result += char(int(text[i] + s - 97) % 26 + 97);
	}
	return result;
}
int main ()
{

string text; int s;
cout<<"Enter the Plain Text:"; cin>>text;
cout<<"Enter the shift value:"; cin>>s;
cout << "Plain Text: " << text; cout << "\nShift: " << s;
cout << "\nCipher Text: " << encrypt (text, s); return 0;

}

SAMPLE INPUT AND OUTPUT:

Enter the Plain Text:zebra 
Enter the shift value:3 
Plain Text : zebra
Shift: 3
Cipher Text: cheud











RESULT:
       Thus, Caesar Cipher substitution technique using C++ is implemented and executed successfully.
EX.NO: 1(a)(ii)
DATE: 19/07/23
IMPLEMENTATION OF CLASSICAL SYMMETRIC ENCRYPTION TECHNIQUES
SUBSTITUTION CIPHERS - IMPLEMENTATION OF VIGENERE CIPHER

AIM:
To implement Vigenere Cipher substitution technique using c++.
ALGORITHM:
1. Start
2. Define a function 'generateKey':
- Parameters: 'string str', 'string key'.
- Initialize 'x' to the length of the input string 'str'.
- Create a 'for' loop that runs indefinitely:
- Initialize 'i' to 0.
- If 'x' is equal to 'i', set 'i' back to 0 to loop around.
- Check if the length of the 'key' string is equal to the length of the 'str'. If it is, exit the loop.
- Append the character at position 'i' in the 'key' string to the end of the 'key' string.
- Return the resulting 'key' string.
3. Define a function 'cipherText':
- Parameters: 'string str', 'string key'.
- Initialize an empty string 'cipher_text'.
- Use a 'for' loop to iterate through each character of the 'str' string:
- Calculate the new character 'x' as '(str[i] + key[i]) % 26'.
- Convert 'x' to uppercase by adding 'A' to it.
- Append 'x' to the 'cipher_text' string.
- Return the 'cipher_text' string.
4. Define a function 'originalText':
- Parameters: 'string cipher_text', 'string key'.
- Initialize an empty string 'orig_text'.
- Use a 'for' loop to iterate through each character of the 'cipher_text' string:
- Calculate the new character 'x' as '(cipher_text[i] - key[i] + 26) % 26'.
- Convert 'x' to uppercase by adding 'A' to it.
- Append 'x' to the 'orig_text' string.
- Return the 'orig_text' string.
5. In the 'main' function:
- Initialize 'str' with the plain text and 'keyword' with the encryption keyword.
- Declare 'key' and 'cipher_text' strings.
- Call the 'generateKey' function to generate the key for encryption.
- Call the 'cipherText' function to encrypt the plain text and store the result in 'cipher_text'.
- Print the ciphertext.
- Call the 'originalText' function to decrypt the ciphertext and print the original/decrypted text.
6. Stop.
PROGRAM:
#include<bits/stdc++.h> using namespace std;
string generateKey(string str, string key)
{

int x = str.size();

for (int i = 0; ; i++)
{

if (x == i)
i = 0;
if (key.size() == str.size()) break;
key.push_back(key[i]);
}

return key;
}

string cipherText(string str, string key)
{

string cipher_text;

for (int i = 0; i < str.size(); i++)
{

char x = (str[i] + key[i]) %26; x += 'A';
cipher_text.push_back(x);
}

return cipher_text;
}

string originalText(string cipher_text, string key)
{

string orig_text;
for (int i = 0 ; i < cipher_text.size(); i++)
{

char x = (cipher_text[i] - key[i] + 26) %26;
x += 'A';
orig_text.push_back(x);
}

return orig_text;
}

int main ()
{

      string str,keyword; 
      cout<<"Enter the Plain Text:"; cin>>str;
cout<<"Enter the Keyword:";
cin>>keyword;
string key = generateKey(str, keyword);
string cipher_text = cipherText(str, key);
cout << "Ciphertext: "<< cipher_text << "\n";
      cout << "Original/Decrypted Text: "<< originalText(cipher_text, key); 
      
      return 0;
}

SAMPLE INPUT AND OUTPUT:
Enter the Plain Text:GREATWORKBYALL Enter the Keyword:WON
Ciphertext: CFRWHJKFXXMNHZ Original/Decrypted Text: GREATWORKBYALL














RESULT:
       Thus, Vigenere Cipher substitution technique using C++ is implemented and executed successfully.
EX.NO: 1(a)(iii)
DATE: 19/07/23
IMPLEMENTATION OF CLASSICAL SYMMETRIC ENCRYPTION TECHNIQUES
SUBSTITUTION CIPHERS - IMPLEMENTATION OF ONE TIME PAD ALGORITHM

AIM:
To implement One Time Pad algorithm, a substitution technique using c++.
ALGORITHM:
1. Start
2. Define the 'stringEncryption' function:
- Parameters: 'string text', 'string key'.
- Initialize an empty string 'cipherText'.
- Create an integer array 'cipher' of the same length as 'key'.
- Iterate over the characters in the 'text' and 'key' strings:
- Calculate 'cipher[i]' as the sum of the ASCII values of corresponding characters in 'text' and 'key', both converted to uppercase.
- Check if 'cipher[i]' is greater than 25, and if so, subtract 26 to ensure it remains in the range [0, 25].
- Convert each 'cipher[i]' value back to an uppercase character and append it to 'cipherText'.
- Return 'cipherText'.
3. Define the 'stringDecryption' function:
- Parameters: 'string s', 'string key'.
- Initialize an empty string 'plainText'.
- Create an integer array 'plain' of the same length as 'key'.
- Iterate over the characters in the 's' and 'key' strings:
- Calculate 'plain[i]' as the difference between the ASCII values of corresponding characters in 's' and 'key', both converted to uppercase.
- Check if 'plain[i]' is less than 0, and if so, add 26 to ensure it remains in the range [0, 25].
- Convert each 'plain[i]' value back to an uppercase character and append it to 'plainText'.
- Return 'plainText'.
4. In the 'main' function:
- Declare 'plainText' and 'key' strings to store user input.
- Prompt the user to enter plain text and the key.
- Convert all characters in 'plainText' and 'key' to uppercase.
- Call the 'stringEncryption' function to encrypt the plain text and store the result in 'encryptedText'.
- Print the cipher text.
- Call the 'stringDecryption' function to decrypt the cipher text and print the original/decrypted text.
5. Stop.

PROGRAM:
#include<bits/stdc++.h
#include <iostream>
using namespace std;
string stringEncryption(string text, string key)
{

string cipherText = ""; int cipher[key.length()];
for (int i = 0; i < key.length(); i++) {
cipher[i] = text.at(i) - 'A' + key.at(i) - 'A';

}
for (int i = 0; i < key.length(); i++) { if (cipher[i] > 25) {
cipher[i] = cipher[i] - 26;

}
}

for (int i = 0; i < key.length(); i++) { int x = cipher[i] + 'A'; cipherText += (char)x;
}
return cipherText;
}
static string stringDecryption(string s, string key)
{

string plainText = ""; int plain[key.length()];
for (int i = 0; i < key.length(); i++) {
plain[i] = s.at(i) - 'A' - (key.at(i) - 'A');

}
for (int i = 0; i < key.length(); i++) { if (plain[i] < 0) {
plain[i] = plain[i] + 26;

}
}
for (int i = 0; i < key.length(); i++) { int x = plain[i] + 'A';
plainText += (char)x;

}
return plainText;
}
int main ()
{

string plainText,key; cout<<"Enter Plain Text:"; cin>>plainText; cout<<"Enter Key:"; cin>>key;
for (int i = 0; i < plainText.length(); i++) { plainText[i] = toupper(plainText[i]);
}
for (int i = 0; i < key.length(); i++) { key[i] = toupper(key[i]);
}
string encryptedText = stringEncryption(plainText, key);
cout << "Cipher Text - " << encryptedText << endl;
cout << "Message - "<< stringDecryption(encryptedText, key);
return 0;
}
SAMPLE INPUT AND OUTPUT:
Enter Plain Text:HELLO 
Enter Key:MONEY
Cipher Text - TSYPM 
Message - HELLO













RESULT:
       Thus, One Time Pad algorithm, a substitution technique using C++ is implemented and executed successfully.
EX.NO: 1(b)(i)
DATE: 19/07/23
IMPLEMENTATION OF CLASSICAL SYMMETRIC ENCRYPTION TECHNIQUES
TRANSPOSITIONAL CIPHERS - IMPLEMENTATION OF RAIL FENCE

AIM:
To implement the Rail Fence Transposition Cipher using C++.

ALGORITHM:
Encryption:
1. The plaintext is written downwards and diagonally on straight rails of an imaginary fence of the given size (number of rows).
2. When the bottom rail is reached, the upward moving diagonal is traversed to reach the top, making that the way of writing the letters in a zig-zag manner.
3. After each letter is fit into the rail fence, the individual rows are combined and appended to obtain the cipher text.

Decryption:
1. The rail matrix is constructed according to the key size. Once we've got the matrix, we can figure out where texts should be placed (using the same way of moving diagonally up and down alternatively).
2. Fill the cipher-text row wise. After filling it, traverse the matrix in zig-zag manner to obtain the original text,
PROGRAM:
#include <iostream> #include <string> using namespace std;
string encryption (string message, int key)
{

string result = "";
int i, j, k = -1, row = 0, col = 0; char railMatrix[key][message.length()]; for (i = 0; i < key; ++i)
for (j = 0; j < message.length();++j) railMatrix[i][j] = '-';
     for (i = 0; i < message.length(); ++i){ 
        railMatrix[row][col++] = message[i];                                   
        if (row == 0 || row == key-1)
            k = k * (-1);
       row = row + k;
}
   cout << "\n The Rail Matrix is:\n"; for (i = 0; i < key; i++)
{

for (j = 0; j < message.length(); j++)
{

cout << railMatrix[i][j] << ' '; if (railMatrix[i][j] != '-')
result += railMatrix[i][j];
}

cout << endl;
}

return result;
string decryption (string message, int key)
{

string result = "";
int i, j, k = -1, row = 0, col = 0, m = 0; char railMatrix[key][message.length()]; for (i = 0; i < key; ++i)
for (j = 0; j < message.length(); ++j) railMatrix[i][j] = '-';
for (i = 0; i < message.length();++i){ 
railMatrix[row][col++] = '*'; 
if (row == 0 || row == key-1)
    k= k * (-1); row = row + k;
}
for (i = 0; i < key; ++i)
for (j = 0; j < message.length(); ++j) if(railMatrix[i][j] == '*')
          railMatrix[i][j] = message[m++];
       row = col = 0;
       k = -1;
for (i = 0; i < message.length(); ++i){ 
result += railMatrix[row][col++]; if (row == 0 || row == key-1)
    k= k * (-1); row = row + k;
}
return result;
}
int main ()
{

int fence;
string message, plain_text, cipher_text; cout << "\n Enter the message: "; getline(cin >> ws, message);
cout << "\n Enter the fence size: "; cin >> fence;
cipher_text = encryption (message, fence);
cout << "\n The Cipher Text is: " << cipher_text; plain_text = decryption (cipher_text, fence); cout << "\n The Plain Text is: " << plain_text; return 0;
}








        
        

SAMPLE INPUT AND OUTPUT:

Enter the message: cybersecurity 
Enter the fence size: 5
The Rail Matrix is:


c-------u-----y-----c-r-----b---e---i-----e-s-----t-----r-------y

The Cipher Text is: cuycrbeiestry 
The Plain Text is: cybersecurity

























RESULT:
The Rail Fence Transposition Cipher has been implemented successfully.
EX.NO: 1(b)(ii)
DATE: 19/07/23
IMPLEMENTATION OF CLASSICAL SYMMETRIC ENCRYPTION TECHNIQUES
TRANSPOSITIONAL CIPHERS - IMPLEMENTATION OF ROW AND COLUMN TRANSFORMATION CIPHER

AIM:
To implement the Row-Column Transformation Cipher using C++.
ALGORITHM:
Encryption
1. The message is written out in rows of a fixed length, and then read out again column by column, and the columns are chosen based on the key.
2. Width of the rows and the permutation of the columns are usually defined by a keyword. Any spare spaces are filled with nulls or left blank or placed by a character.
3. The message is read off in columns, in the order specified by the keyword.

Decryption
1. The column lengths have to be worked by dividing the message length by the key length.
2. Write the message out in columns again, then reorder the columns by reforming the keyword.
PROGRAM:
#include <iostream> #include <string> #include <map> #include <algorithm> using namespace std; map<int, int> keyMap; char matrix[100][100];

void set_permutation_order (string key)
{
for (int i = 0; i < key.length(); i++)
{
keyMap[key[i]] = i;
}
}
void print_matrix (int row, int column)
{
for (int i = 0; i < row; i++)
{
for (int j = 0; j < column; j++)
{
cout << "\t" << matrix[i][j];
}
cout << endl;
}
}
string encryption (string message, string key)
{
int row, column; string result = ""; column = key.length();
row = message.length() / column; if (message.length() % column)
row += 1;
for (int i = 0, k = 0; i < row; i++)
{
for (int j = 0; j < column;)
{
if (message[k] == '\0')
{
matrix[i][j] = '-'; j++;
}


if (isalpha(message[k]) || message[k] == ' ')
{


                                matrix[i][j] = message[k]; 
                 j++;

} k++;
}

cout << "\n\n Encryption: Transpositional Matrix: " << endl; print_matrix(row, column);

for (map<int,int>::iterator it = keyMap.begin(); it !=keyMap.end();++it)
{
int j = it->second;
for (int i = 0; i < row; i++)
{
if(isalpha(matrix[i][j]) || matrix[i][j]=' ' || matrix[i][j]=='-') 
           result += matrix[i][j];
           }
      }
      return result;
}
string decryption (string message, string key)
{
int row, column; string result = ""; column = key.length();
row = message.length() / column; if (message.length() % column)
row += 1;
for (int j = 0, k = 0; j < column; j++) for (int i = 0; i < row; i++)
matrix[i][j] = message[k++];
cout << "\n\n Decryption: Transpositional Matrix: " << endl; print_matrix(row, column);
int index = 0;
for (map<int,int>::iterator it = keyMap.begin(); it != keyMap.end();++it)
    it->second = index++; char decipher[row][column];
map<int, int>::iterator it = keyMap.begin(); int k = 0;
for (int l=0,j; key[l]!='\0'; k++)
{
j = keyMap[key[l++]];
for (int i = 0; i < row; i++)
{
decipher[i][k] = matrix[i][j];
}
}
for (int i = 0; i < row; i++)
for (int j = 0; j < column; j++)
{
if (decipher[i][j] != '-') result += decipher[i][j];
}


return result;
}
int main ()
{
string message, plain_text, cipher_text, key; cout << "\n Enter the Key Value: ";
cin >> key; set_permutation_order(key);
cout << "\n Enter the Plain Text Message: "; getline(cin >> ws, message);
transform(message.begin(), message.end(), message.begin(), ::toupper); cipher_text = encryption(message, key);
cout << "\n The Cipher Text: \t" << cipher_text; plain_text = decryption(cipher_text, key);
cout << "\n The Plain Text: \t" << plain_text; return 0;
}
SAMPLE INPUT AND OUTPUT:
Enter the Key Value: ALGORITHM
Enter the Plain Text Message: CYBER SECURITY IS ESSENTIAL
Encryption: Transpositional Matrix:
C	Y	B	E	R		S	E	C
U	R	I	T	Y		I	S	
E	S	S	E	N	T	I	A	L

The Cipher Text:	CUEBISESA TYRSC LETERYNSII

Decryption: Transpositional Matrix:
C	B	E		Y	C	E	R	S
U	I	S		R		T	Y	I
E	S	A	T	S	L	E	N	I

The Plain Text: CYBER SECURITY IS ESSENTIAL
























RESULT:
The Row-Column Transformation Cipher has been implemented successfully.
EX.NO: 2
DATE: 02/08/23
IMPLEMENTATION OF SDES ALGORITHM

AIM:
To implement the Simplified Data Encryption Standard Algorithm using Java.

ALGORITHM:
Key Generation:
1. We accepted a 10-bit key and permuted the bits by putting them in the P10 table.
2. We divide the key into 2 halves of 5-bit each. Now we apply one-bit left shift on each key.
3. Combine both keys after step 2 and permute the bits by putting them in the P8 table. The output of the given table is the first key K1.
4. The output obtained from step 2 i.e., 2 halves after one-bit left shift should again undergo the process of two-bit left shift.
5. Combine the 2 halves obtained from step 4 and permute them by putting them in the P8 table. The output of the given table is the second key K2.

Encryption:
1. We perform initial permutation on our 8-bit plain text using the IP table.
2. After the initial permutation, we get an 8-bit block of text which we divide into 2 halves of 4 bit each.
3. On the right half, we perform expanded permutation using EP table which converts 4 bits into 8 bits.
4. We perform XOR operation using the first key K1 with the output of expanded permutation.
5. Again, we divide the output of XOR into 2 halves of 4 bit each.
6. We take the first and fourth bit as row and the second and third bit as a column for our S boxes.
7. S boxes gives a 2-bit output which we combine to get 4 bits and then perform permutation using the P4 table.
8. We XOR the output of the P4 table with the left half of the initial permutation table i.e., IP table.
9. We combine both halves i.e., right half of initial permutation and output of ip.
10. Now, divide the output into two halves of 4 bit each. Combine them again, but now the left part should become right, and the right part should become left.
11. Again, perform step 2, but this time while doing XOR operation after expanded permutation use key 2 instead of key 1.
12. Perform inverse initial permutation. The output of this table is the cipher text of 8 bit.

Decryption:
1. We perform initial permutation on our 8-bit cipher text using the IP table.
2. After the initial permutation, we get an 8-bit block of text which we divide into 2 halves of 4 bit each.
3. On the right half, we perform expanded permutation using EP table which converts 4 bits into 8 bits.
4. We perform XOR operation using the first key K2 with the output of expanded permutation.
5. Again, we divide the output of XOR into 2 halves of 4 bit each.
6. We take the first and fourth bit as row and the second and third bit as a column for our S boxes.
7. S boxes gives a 2-bit output which we combine to get 4 bits and then perform permutation using the P4 table.
8. We XOR the output of the P4 table with the left half of the initial permutation table i.e., IP table.
9. We combine both halves i.e., right half of initial permutation and output of ip.
10. Now, divide the output into two halves of 4 bit each. Combine them again, but now the left part should become right, and the right part should become left.
11. Again, perform step 2, but this time while doing XOR operation after expanded permutation use key 1 instead of key 2.
12. Perform inverse initial permutation. The output of this table is the cipher text of 8 bit.

PROGRAM:
import java.io.*; public class SDES {
int key[] = {1, 0, 1, 0, 0, 0, 0, 0, 1, 0};
int P10[] = {3, 5, 2, 7, 4, 10, 1, 9, 8, 6};
int P8[] = {6, 3, 7, 4, 8, 5, 10, 9};
int key1[] = new int[8]; int key2[] = new int[8];
int[]IP={2,6,3,1,4,8,5, 7 };int[]EP={4,1,2,3,2,3,4, 1 };int[]P4={2,4,3,1 };
       int[] IP_inv = { 4, 1, 3, 5, 7, 2, 8, 6 };
        int[][] S0 = { {1, 0, 3, 2},{3, 2, 1, 0},{0, 2, 1, 3},{3, 1, 3, 2} };
        int[][] S1 = { {0, 1, 2, 3},{2, 0, 1, 3},{3, 0, 1, 0},{2, 1, 0, 3} };
     void key_generation()
{

int key_[] = new int[10];

for (int i = 0; i < 10; i++) { key_[i] = key[P10[i] -1];
}
int Ls[] = new int[5]; int Rs[] = new int[5];
for (int i = 0; i < 5; i++) { Ls[i] = key_[i];
Rs[i] = key_[i + 5];

}
int[] Ls_1 = shift(Ls, 1); int[] Rs_1 = shift(Rs, 1); for (int i = 0; i < 5; i++) {
key_[i] = Ls_1[i]; key_[i + 5] = Rs_1[i];
}
for (int i = 0; i < 8; i++) { key1[i] = key_[P8[i] -1];
}
int[] Ls_2 = shift(Ls, 2); int[] Rs_2 = shift(Rs, 2);
for (int i = 0; i < 5; i++)
{ 
                                   key_[i] = Ls_2[i];
                     key_[i + 5] = Rs_2[i];
}
for (int i = 0; i < 8; i++) { key2[i] = key_[P8[i] -1];
}
                System.out.println("Your Key-1 :"); 
                                                           for (int i = 0; i < 8; i++)
System.out.print(key1[i] + " ");
                                                             System.out.println(); 
               System.out.println("Your Key-2 :");                                              
             for (int i = 0; i < 8; i++)
System.out.print(key2[i] + " ");
              }
            int[] shift(int[] ar, int n)
     {

while (n > 0) {
int temp = ar[0];
for (int i = 0; i < ar.length - 1; i++) { ar[i] = ar[i + 1];
}
ar[ar.length - 1] = temp; n--;
}

return ar;
  }
int[] encryption(int[] plaintext)
{

int[] arr = new int[8];
for (int i = 0; i < 8; i++) {
arr[i] = plaintext[IP[i] - 1];
}
int[] arr1 = function_(arr, key1);
int[] after_swap = swap(arr1, arr1.length / 2); int[] arr2 = function_(after_swap, key2); int[] ciphertext = new int[8];
for (int i = 0; i < 8; i++) {
 ciphertext[i] = arr2[IP_inv[i] -1];
}
return ciphertext;
}
  
                                                                                                                                                                                                                                                                        String binary_(int val)
{

if (val == 0)    return "00";
else if (val == 1) return "01";
 else if (val == 2) return "10"; 
else return "11";
}

int[] function_(int[] ar, int[] key_)
{

int[] l = new int[4]; int[] r = new int[4];
for (int i = 0; i < 4; i++) { l[i] = ar[i];
r[i] = ar[i + 4];

}
int[] ep = new int[8];
for (int i = 0; i < 8; i++) { ep[i] = r[EP[i] - 1];
              }
for (int i = 0; i < 8; i++) {
ar[i] = key_[i] ^ ep[i];
}
int[] l_1 = new int[4]; int[] r_1 = new int[4];
for (int i = 0; i < 4; i++) { l_1[i] = ar[i];
r_1[i] = ar[i + 4];

}
int row, col, val;
row = Integer.parseInt("" + l_1[0] + l_1[3], 2); col = Integer.parseInt("" + l_1[1] + l_1[2], 2); val = S0[row][col];
String str_l = binary_(val);
row = Integer.parseInt("" + r_1[0] + r_1[3], 2); col = Integer.parseInt("" + r_1[1] + r_1[2], 2); val = S1[row][col];
String str_r = binary_(val); int[] r_ = new int[4];
for (int i = 0; i < 2; i++) { 
char c1 = str_l.charAt(i); 
char c2 = str_r.charAt(i);
r_[i] = Character.getNumericValue(c1); 
r_[i + 2] = Character.getNumericValue(c2);
              }
int[] r_p4 = new int[4];
for (int i = 0; i < 4; i++) { r_p4[i] = r_[P4[i] - 1];
}
for (int i = 0; i < 4; i++) { l[i] = l[i] ^ r_p4[i];
}
int[] output = new int[8]; for (int i = 0; i < 4; i++) {
output[i] = l[i]; output[i + 4] = r[i];
}
return output;
     }
 int[] swap(int[] array, int n)
     {

int[] l = new int[n]; int[] r = new int[n];
for (int i = 0; i < n; i++) { l[i] = array[i];
r[i] = array[i + n];

}
int[] output = new int[2 * n]; for (int i = 0; i < n; i++) {
output[i] = r[i]; output[i + n] = l[i];
}
return output;
           }
int[] decryption(int[] ar)
{

int[] arr = new int[8];
for (int i = 0; i < 8; i++) {
 arr[i] = ar[IP[i] - 1];
                }
         int[] arr1 = function_(arr, key2);
         int[] after_swap = swap(arr1, arr1.length / 2); 
         int[] arr2 = function_(after_swap, key1); 
         int[] decrypted = new int[8];
         for (int i = 0; i < 8; i++) { 
decrypted[i] = arr2[IP_inv[i] - 1];
}
return decrypted;
        }
public static void main(String[] args)
{
SDES obj = new SDES();
 obj.key_generation();
int[] plaintext = {1, 0, 0, 1, 0, 1, 1, 1};
System.out.println(); System.out.println("Your plain Text is :");
               for (int i = 0; i < 8; i++)	
          System.out.print(plaintext[i] + " ");
int[] ciphertext = obj.encryption(plaintext); System.out.println(); System.out.println("Your cipher Text is :");
               for (int i = 0; i < 8; i++)
   System.out.print(ciphertext[i] + " ");
int[] decrypted = obj.decryption(ciphertext); System.out.println();
System.out.println("Your decrypted Text is :");
               for (int i = 0; i < 8; i++)
   System.out.print(decrypted[i] + " ");
}
            }

SAMPLE INPUT AND OUTPUT:
Your Key-1 :
1 0 1 0 0 1 0 0
Your Key-2 :
0 1 0 0 0 0 1 1
Your plain Text is :
1 0 0 1 0 1 1 1
Your cipher Text is :
0 0 1 1 1 0 0 0
Your decrypted Text is :
1 0 0 1 0 1 1 











RESULT:
      The Simplified Data Encryption Standard Algorithm has been implemented        successfully.

EX.NO: 3
DATE: 09/08/23
IMPLEMENTATION OF RSA ALGORITHM

AIM:
To implement the Rivest-Shamir-Adler Algorithm using C++.
ALGORITHM:
1. Start
2. Read two prime numbers
3. Calculate the product as n = p * q
4. Calculate the Euler Totient Function as phi = (p-1)*(q-1)
5. Calculate the public key e such that it is co-prime to phi(n) and private key d such that ed
= 1 mod phi(n)
6. Find the Cipher Text as C = Pe (mod n)
7. Find the Plain Text as P = Cd (mod n)
8. Stop

PROGRAM:
#include <iostream> #include <cmath> 
using namespace std; 
int gcd (int a, int b)
{
if (b == 0)

return a;

return gcd(b, a % b);

}
int mod_inverse (int a, int m)

{
int x;

for (x = 1; x < m; x++)

if (((a % m) * (x % m)) % m == 1) break;
return x;
  }
  
long long mod_pow (long long base, long long exp, long long mod)

{
long long result = 1; base = base % mod; while (exp > 0)
{
if (exp % 2 == 1)

{
result = (result * base) % mod;
}

base = (base * base) % mod; exp /= 2;
}
return result;
}
int main ()

{
long long int p, q, n, phi, e, d;

cout << "\n Enter the prime number -- p = :"; cin >> p;
cout << "\n Enter the prime number -- q = :"; cin >> q;
n = p * q;
phi = (p - 1) * (q - 1);
for (int i = 2; i < phi; i++)

{
if (gcd(phi, i) == 1)

{
e = i; break;
}
}
d = mod_inverse(e, phi);

cout << "\n The Prime Number -- P = \t" << p; cout << "\n The Prime Number -- Q = \t" << q; cout << "\n The Product -- N = P X Q = \t" << n;
cout << "\n The Euler Totient Function -- PHI = \t" << phi; cout << "\n The Public Key -- E = \t" << e;
cout << "\n The Private Key -- D = \t" << d; long long int message, plain_text, cipher_text; cout << "\n Enter the message: ";
cin >> message;
cipher_text = mod_pow(message, e, n); 
cout << "\n \t Cipher: " << cipher_text;
plain_text = mod_pow(cipher_text, d, n);
cout << "\n \t Plain: " << plain_text; return 0;
}

SAMPLE INPUT AND OUTPUT:

Enter the prime number -- p = : 3
Enter the prime number -- q = : 7
The Prime Number -- P = 3
The Prime Number -- Q = 7
The Product -- N = P X Q = 21
The Euler Totient Function -- PHI = 12
The Public Key -- E =	5
The Private Key -- D = 5
Enter the message:12
Cipher: 3
Plain: 12

RESULT:
The Rivest-Shamir-Adler Algorithm has been implemented successfully.
EX.NO: 4
DATE: 16/08/23
IMPLEMENTATION OF DIFFIEE - HELLMAN EXCHANGE ALGORITHM

AIM:
To implement the Diffiee-Hellman Key Exchange Algorithm using C++.

ALGORITHM:
Prime Number and Primitive Root Generation:
1. Get a prime number (p) from the user.
2. In modular arithmetic, a number g is a primitive root modulo n if every number a coprime to n is congruent to the power of g modulo n.
3. The primitive root of a prime number n is an integer r between [1, n-1] such that the values of r^x(mod n) where x is in the range[0, n-2] are different.
4. Example: The primitive root of 5 is 2 

Secret Key Generation:
1. Get the private keys of the sender and receiver, a and b respectively.
2. Calculate their public keys, using the arithmetic notations:
? Public Key (A) = X = primitive_root(p) ^ a (mod p)
? Public Key (B) = Y = primitive_root(p) ^ b (mod p)
3. Calculate the secret key, using the given formulae:
? Secret Key - Y ^ A (mod p) == X ^ B (mod p).

PROGRAM:
#include <iostream> #include <cstdlib> #include <cmath> #include<unordered_set>
using namespace std;
void find_prime_factors(unordered_set<int> &s, int phi)
{
while (phi % 2 == 0)
{
s.insert(2); phi /= 2;
}
for (int i = 3; i <= sqrt(phi); i = i+2)
{
while (phi % i == 0)
{
s.insert(i); phi /= i;
}
       }
if (phi > 2)
s.insert(phi);
  }
int power (int x, unsigned int y, int p)
{
int res = 1;
 x = x % p;

while (y > 0)
{
if (y & 1)
res = (res*x) % p;

y = y >> 1; 
y = y/2 x = (x*x) % p;
}
return res;
}
int primitive_root (int n)
{
unordered_set<int> s; int phi = n-1;

find_prime_factors (s, phi);
cout << "\n The Prime Factors are of phi (" << phi <<") = ";

for (auto it = s.begin(); it != s.end();it++)     cout << "\t" << *it;
       cout << endl << endl;
        
for (int r=2; r<=phi; r++)
{
bool flag = false;

for (auto it = s.begin(); it != s.end(); it++)
{
if (power (r, phi/(*it), n) == 1)
{
flag = true; break;
}
}

if (flag == false) return r;
}
return -1;
}
int power_dhke(int a , int b, int P)
{
if (b == 1)
return a;
else
    return (((long long int)pow(a, b)) % P);
  }
 int main ()
{
int p;
cout << "\n Enter the prime number:"; cin >> p;
int alpha = primitive_root(p);
cout << "\n The Primitive Root is: " << alpha << endl << endl; int a, b, x, y, ka, kb;
cout << "\n Enter the private key of A:"; cin >> a;
x = power_dhke(alpha, a, p);
cout << "\n The Public Key of A: " << x << endl << endl; cout << "\n Enter the private key of B: ";
cin >> b;
y = power_dhke(alpha, b, p);
cout << "\n The Public Key of B: " << y << endl << endl; ka = power(y, a, p); 
kb = power(x, b, p); 
cout << "\n Secret key for the A is : " << ka << endl; cout << "\n Secret key for the B is : " << kb << endl; return 0;
}

SAMPLE INPUT AND OUTPUT:

Enter the prime number: 51
The Prime Factors are of phi (50) = 5 2 
The Primitive Root is: 2
Enter the Private Key of A:4 
The Public Key of A: 16
Enter the Private Key of B:3 
The Public Key of B: 8
Secret Key for the A is : 16 Secret Key for the B is : 16







RESULT:
The Diffie-Hellman Key Exchange Algorithm has been implemented successfully.
EX.NO: 5
DATE:  23/08/23
STUDY OF DIFFERENT WIRELESS NETWORK COMPONENTS AND FEATURES OF ANY ONE OF THE MOBILE SECURITY APPS

AIM:
    To study different wireless network components and features of the norton mobile security app.

WIRELESS NETWORK COMPONENTS:

1. Wireless Access Points (APs): These are devices that allow wireless devices to connect to a wired network. They create Wi-Fi networks and transmit data between devices and the network.

2. Wireless Routers: These devices often combine a wireless access point with a router and act as a central hub for a local area network. They assign IP addresses and manage data traffic.

3. Wireless Clients: These are the devices that connect to the wireless network, such as laptops, smartphones, and tablets.

4. Wireless Network Interface Cards (NICs): These are the hardware components in a device that enable it to connect to a wireless network.

5. SSID (Service Set Identifier): It's the name of the wireless network that devices use to identify and connect to a particular network.

6. Encryption and Authentication: Wireless networks often use security protocols like WPA2 or WPA3 to encrypt data and require a password or authentication mechanism for access.

7. Firewalls and Intrusion Detection Systems: These components help protect wireless networks from unauthorized access and cyber threats.

8. Frequency Bands: Wi-Fi operates in various frequency bands, including 2.4 GHz and 5 GHz. Different bands offer different speeds and coverage.

9. Channel: In crowded areas, networks can interfere with each other. The choice of channel can affect network performance.

10. Antennas: The design and placement of antennas affect the coverage and signal strength of a wireless network.

MOBILE SECURITY APP FEATURES (EXAMPLE: NORTON MOBILE SECURITY):

Norton Mobile Security is one of many mobile security apps designed to protect smartphones and tablets. Here are some typical features:

1. Antivirus and Malware Protection: Scans apps and files for malware and other security threats, ensuring your device is free from viruses.

2. App Advisor: Provides information on the privacy and security risks of installed apps.

3. Web Protection: Blocks malicious websites, phishing attempts, and unsafe links, keeping your browsing safe.

4. Anti-Theft Features: Allows you to remotely lock, locate, or wipe your device in case it's lost or stolen. Some apps even take a photo of the thief.

5. Privacy Protection: Monitors apps for privacy risks, such as those accessing your personal information without permission.

6. Wi-Fi Security: Scans Wi-Fi networks for vulnerabilities and warns you about potential risks when connecting to public Wi-Fi.

7. Parental Control: Helps parents monitor and control their children's device usage, including app restrictions and content filtering.

8. Backup and Restore: Some mobile security apps offer backup solutions for your data, allowing you to restore it if your device is lost or damaged.

9. Call and Text Blocking: Lets you block unwanted calls and text messages.

10. Device Optimization: Provides tools to optimize device performance by cleaning up junk files and managing battery usage.

11. Identity Protection: Monitors for identity theft and alerts you if your personal information is compromised.

















RESULT:
              The different wireless network components and features of the norton mobile security app has been studied.

EX.NO: 6
DATE: 30/08/23
STUDY OF THE FEATURES OF FIREWALL IN PROVIDING NETWORK SECURITY AND TO SET FIREWALL SECURITY IN WINDOWS

AIM:
    To study the features of firewall in providing network security and to set firewall security in windows.

FIREWALL:

A Firewall is a hardware or software to prevent a private computer or a network of computers from unauthorized access, it acts as a filter to avoid unauthorized users from accessing private computers and networks. It is a vital component of network security. It is the first line of defense for network security. It filters network packets and stops malware from entering the user's computer or network by blocking access and preventing the user from being infected. 

FEATURES OF FIREWALL IN PROVIDING NETWORK SECURITY:

Physical Barrier: A firewall does not allow any external traffic to enter a system or a network without its allowance. A firewall creates a choke point for all the external data trying to enter the system or network and hence can easily block access if needed.
Multi-Purpose: A firewall has many functions other than security purposes. It configures domain names and Internet Protocol (IP) addresses. It also acts as a network address translator. It can act as a meter for internet usage.
Flexible Security Policies: Different local systems or networks need different security policies. A firewall can be modified according to the requirement of the user by changing its security policies.
Security Platform: It provides a platform from which any alert to the issue related to security or fixing issues can be accessed. All the queries related to security can be kept under check from one place in a system or network.
Access Handler: Determines which traffic needs to flow first according to priority or can change for a particular network or system. specific action requests may be initiated and allowed to flow through the firewall.

FIREWALL SECURITY IN WINDOWS:

Windows Defender Firewall helps prevent hackers and malicious software from gaining access to your PC through the internet or a network. Your organization might require you to turn it on before you can access their network resources from your device.

To turn on Windows Defender Firewall:
1.Go to Start and open Control Panel.
2.Select System and Security > Windows Defender Firewall.
3.Choose Turn Windows Firewall on.
4.Select Turn on Windows Firewall for domain, private, and public network settings.





STEP 1:






STEP 2:















STEP 3:




STEP 4:





RESULT:
       The features of firewall in providing network security is studied and firewall security in windows is set.
EX.NO: 7
DATE: 02/09/23
STEPS TO ENSURE SECURITY OF ANY ONE WEB BROWSER

AIM:
    To provide the steps to ensure security of the web browsers Google Chrome and Mozilla Firefox.

SECURITY MEASURES IN GOOGLE CHROME:






SECURITY MEASURES IN MOZILLA FIREFOX:

Phishing and malware protection:

                 These features will warn you when a page you visit has been reported as a Deceptive Site (sometimes called "phishing" pages), as a source of Unwanted Software or as an Attack Site designed to harm your computer (otherwise known as "malware").
                 



Firefox Monitor:

              Firefox Monitor warns you if your online accounts were involved in a known data breach. It also empowers users to fight against data breaches by alerting them when they visit a previously breached website.
              



HTTPS-Only mode:

            This security-enhancing mode forces all connections to websites to use a secure encrypted connection called HTTPS.
            




RESULT:
    The steps to ensure security of Google Chrome and Mozilla Firefox is provided.
    
EX.NO: 8
DATE: 06/09/23
STUDY OF DIFFERENT TYPES OF VULNERABILITIES FOR HACKING WEBSITES / WEB APPLICATIONS

AIM:
    To study the different types of vulnerabilities for hacking websites / web applications.

COMMON VULNERABILITIES:

There are six common types of website vulnerabilities that are frequently exploited by attackers. 

1.SQL Injections:
SQL injection vulnerabilities refer to areas in website code where direct user input is passed to a database. Bad actors utilize these forms to inject malicious code, sometimes called payloads, into a website's database. This allows the cybercriminal to access the website in a variety of ways, including:

- Injecting malicious/spam posts into a site
- Stealing customer information
- Bypassing authentication to gain full control of the website
Due to its versatility, SQL injection is one of the most commonly exploited website vulnerabilities. It is frequently used to gain access to open-source content management system (CMS) applications.

2.Cross-Site Scripting (XSS):
Cross-site scripting occurs when attackers inject scripts through unsanitized user input or other fields on a website to execute code on the site. Cross-site scripting is used to target website visitors rather than the website or server. This often means attackers are injecting JavaScript into the website so that the script is executed in the visitor's browser. Browsers are unable to discern whether or not the script is intended to be part of the website, resulting in malicious actions, including:

- Session hijacking
- Spam content being distributed to unsuspecting visitors
- Stealing session data
Some of the largest-scale attacks against WordPress have been from cross site-scripting vulnerabilities. However, XSS is not limited only to open-source applications. 

3.Command Injections:
Command injection vulnerabilities allow attackers to remotely pass and execute code on the website's hosting server. This is done when user input that is passed to the server, such as header information, is not properly validated, allowing attackers to include shell commands with the user information. Command injection attacks are particularly critical because they can allow bad actors to initiate the following:

- Hijack an entire site
- Hijack an entire hosting server
- Utilize the hijacked server in botnet attacks
One of the most dangerous and widespread command injection vulnerabilities was the Shellshock vulnerability that impacted most Linux distributions.

4.File Inclusion (LFI/RFI):
Remote file inclusion (RFI) attacks use include functions in server-side web application languages like PHP to execute code from a remotely stored file. Attackers host malicious files and then take advantage of improperly sanitized user input to inject or modify an include function into the victim site's PHP code. This inclusion can then be used to initiate the following:

- Deliver malicious payloads that can be used to include attack and phishing pages in a visitors' browsers
- Include malicious shell files on publicly available websites
- Take control of a website admin panel or host server

Local File Inclusion (LFI), like remote file inclusion, can occur when user input is able to modify the full or absolute path to included files. Attackers can then use this vector to gain, read or write access to sensitive local files- for example, configuration files containing database credentials. The attacker could also perform a directory traversal attack, amending an included file path to review the back end and host server files and expose sensitive data. A local file inclusion attack has the potential to become a remote file inclusion attack.

These types of vulnerabilities are frequently used to launch other attacks, such as DDoS and cross-site scripting attacks. They have also been used to expose and steal sensitive financial information.

5.Cross-Site Request Forgery (CSRF):
Cross-site request forgery attacks are less common but can be quite damaging. CSRF attacks trick site users or administrators into unknowingly performing malicious actions for the attacker. As a result, attackers may be able to take the following actions using valid user input:

- Change order values and product prices
- Transfer funds from one account to another
- Change user passwords to hijack accounts
These types of attacks are particularly vexing for eCommerce and banking sites where attackers can gain access to sensitive financial information. A CSRF attack was recently used to seize all control of a Brazilian bank's DNS settings for over five hours.

6.Security Misconfigurations:
When security controls and configurations in any layer of a website, such as application, web server, network services, platform, framework, and databases, are set up incorrectly, security issues can occur, including:

- Using legacy components (unused pages, features, unpatched software, etc.)
- Leaving unnecessary admin ports open
- Enabling outbound connections to internet services, directory services








RESULT:
    The different types of vulnerabilities for hacking websites / web applications are studied.
EX.NO: 9
DATE: 13/09/23 
ANALYSIS OF SECURITY VULNERABILITIES OF E-COMMERCE SERVICES

AIM:
    To analyse security vulnerabilities of e-commerce services.

What Is a Security Vulnerability in e-Commerce?
In the e-Commerce industry, security vulnerability stands for the weak points of the system that can be easily attacked by scammers or prone to various fraudulent activities for getting money, products, and personal information from clients' bases for the purpose of profit.

SECURITY VULNERABILITIES OF E-COMMERCE SERVICES:
1. Financial Frauds or Payment Frauds:
- This type is one of the most typical for eCommerce and dates back to the very first attempts of the businesses going online. Often, scammers used to make unauthorized transactions and immediately wipe out the trails. Or else, they can use the fake emails, accounts, and names, and even IP addresses to look like the real customer.
- After they have requested a refund with, for eg, a fake screenshot, most eCommerce platforms basically give them money for nothing, especially if they're not aware of this financial trick.
- With being reported in over 70% of all attacks, payment frauds are still one of the top reasons why companies experience huge cost losses.

Solution:
Make sure your eCommerce platform cooperates only with verified and authoritative payment systems. Additionally, some companies make it possible to conduct a transaction only after logging in to the individual account before any purchase, which minimizes the risks of financial fraud and prevents common security vulnerabilities as well.

2.Spam attacks:
-Though emails are considered to be the most powerful marketing channel for eCommerce, they are also the typical web security vulnerabilities hackers can easily take advantage of.
-The random comments left on the product pages, under your blog posts, or the contact forms can not only harm the customers' trust but also slow down your platform as well.
-Needless to say, that one infected link left by a spammer is more than enough to affect your site's speed, provide access to personal customer information and other sensitive data.
-Additionally, the spamming activity can become a serious threat to the customers' security as well, which can easily undermine your site's credibility.

Solution:
-Use anti-spamming software for security vulnerabilities detection and its successful removal. Such software can easily spot the infected URLs and safely remove them from your site.
-Typically, such software type uses various algorithms to filter the comments and detect the computer-generated links which can be potentially dangerous for your site's security, and even provide you with the details about the email of the actual sender if it is possible.

3. Triangulation Fraud:
- One of the most recent and large-scale security vulnerabilities detected nowadays is triangulation fraud. This stands for creating a fake site with an identical interface and products at a cheaper price.
- After the customers complete the transaction, they basically donate the money to the criminals, as the products they wanted to purchase simply don't exist and never be shipped to them.
- The reason why this type of fraud is harmful to your eCommerce platform is that you can lose your new clients, loyal customers, and their trust as well: no one wants to go back to the site (even with the slight differences in a brand's name or interface) after being cheated there at once.

Solution:
- Basically, no one can stop scammers from creating a platform that looks just like your online store. However, it's possible to prevent your customers from being fooled by simply informing them about this issue and pointing out the real domain of your eCommerce platform.
- Even a simple information letter can in fact prevent your customers from money loss and also strengthen your store's authority as well.

4. Web Application Security Vulnerabilities:
- At present, the level of competition in different business areas makes companies do their best to meet all the customers' needs. For online stores, web applications are simply a must to attract more clients to their platform.
- For instance, it's essential for eCommerce clients to create the wish lists of the products they want to buy next, look for the featured products, check the special offers and get the personalized list of products they are probably interested in.
- The use of smartphones has only enhanced the demand for web app creation. However, having created one is still not that easy as to maintain and update it regularly.
- Developers should not only focus on the customer experience and comfortable interface but also on the software security vulnerabilities as well. Having omitted this stage of web app development, you can easily give a green light to the criminals for the attack. They can easily play with fake transactions and refunds, gift cards, and even the critical data of your eCommerce platform.

Solution:
- Find a dedicated team of developers you can trust, and ask them to conduct the app checking for the bugs, error codes, and other software issues that need to be fixed.
- Additionally, professional app developers can try various scenarios of hacking, such as cookie poisoning, remote command execution, cross-site scripting, etc to check the specific software security vulnerability of your app and easily resolve it.

5. Bot Attack:
-Some criminals also attack eCommerce sites with bots, that basically act like real users and can hardly be detected by the security system.
-This is why bot attack is considered to be one of the common security vulnerabilities you should always keep in mind. Usually, you can check the bot traffic in the site's analytics and get the records about the exact time and details of their behaviour.
-However, bots are not just fake users that can boost your traffic to slow down the site's speed. Instead, they can also steal the personal information of your customers, record their log-in credentials and bank information, manipulate the products' prices and randomly block them, thus making your eCommerce platform less secure and user-friendly.

Solution:
- To make sure your site is secure enough and won't go down during any of the hacking attempts, always introduce a CAPTCHA test for critical actions such as logging in or products' purchase.
- In addition, track the traffic and block the one generated from the suspicious sources, analyse the failed log-in attempts and protect your mobile apps.
- Large companies also consider employing bot migration software - the perfect solution for minimizing IT security vulnerabilities.
6. Brute Force Attacks:
- Brute-force attacks refer to the hacking method of guessing the system passwords. So far that's one of the most dangerous security vulnerability types that can attack your online store's panel and attempt to get full access to it.
- During this attack, the various programs and complex algorithms are used to generate any possible combination to crack your site's password. After that, any scenario is possible: criminals can ask for the reward or steal the client's personal data, send spam offers, etc - all they planned to do since the site owner has lost access to the admin panel.

Solution:
- This attack can't be predicted but can be prevented instead. For minimizing the site's security vulnerability, developers recommend using strong, complex passwords and do not store them on your digital files, computer documents, browsers, etc.
- In addition to that, you can protect the site by changing the password regularly (for instance, on a monthly basis or once a quarter).


































RESULT:
      The security vulnerabilities of e-commerce services are analysed.
EX.NO: 10
DATE: 20/09/23
          ANALYSIS OF SECURITY VULNERABILITIES OF E-MAIL APPLICATION

AIM:
    To analyse security vulnerabilities of e-mail application.

What Is a Security Vulnerability in e-mail application?

Security vulnerabilities in email applications are a significant concern, as they can lead to data breaches, unauthorized access, and the compromise of sensitive information. 

SECURITY VULNERABILITIES OF E-MAIL APPLICATION AND THEIR SOLUTION:

1. Phishing Attacks:
   - Vulnerability: Users can receive phishing emails that impersonate legitimate senders, leading them to click on malicious links or provide sensitive information.
   - Solution: Educate users about how to recognize phishing emails, use email filtering software to detect and block phishing attempts, and implement email authentication protocols like SPF, DKIM, and DMARC to verify sender authenticity.

2. Malware and Email Attachments:
   - Vulnerability: Malicious attachments or links in emails can infect the recipient's device with malware.
   - Solution: Use antivirus software to scan attachments, avoid downloading attachments from untrusted sources, and educate users about safe email practices.

3. Email Spoofing:
   - Vulnerability: Attackers can forge sender email addresses to make their emails appear legitimate.
   - Solution: Implement email authentication protocols like SPF, DKIM, and DMARC to prevent email spoofing and verify sender authenticity.

4. Weak Passwords and Credential Theft:
   - Vulnerability: Weak or easily guessable passwords can lead to unauthorized access to email accounts.
   - Solution: Encourage users to use strong, unique passwords and enable two-factor authentication (2FA) to add an extra layer of security.

5. Brute Force Attacks:
   - Vulnerability: Attackers may attempt to gain access to email accounts through repetitive login attempts.
   - Solution: Implement account lockout policies that temporarily block access after multiple failed login attempts, making it difficult for attackers to conduct brute force attacks.

6. Insufficient Email Encryption:
   - Vulnerability: Lack of end-to-end encryption can expose email content to eavesdroppers.
   - Solution: Use end-to-end encryption solutions, like PGP or S/MIME, to secure email content in transit.


7. Data Leakage and Attachment Exfiltration:
   - Vulnerability: Sensitive data can be accidentally leaked or intentionally exfiltrated via email attachments.
   - Solution: Implement data loss prevention (DLP) policies to monitor and prevent the unauthorized sharing of sensitive information.

8. Email Eavesdropping:
   - Vulnerability: Unencrypted email communications can be intercepted, read, or monitored by third parties during transmission.
   - Solution: Always use secure email protocols, such as TLS/SSL, to encrypt email communication in transit.

9. Lack of Two-Factor Authentication (2FA):
   - Vulnerability: Failing to implement 2FA or multi-factor authentication can make email accounts more vulnerable to unauthorized access.
   - Solution: Encourage users to enable 2FA to add an extra layer of security to their accounts.

10. Third-Party Service Vulnerabilities:
   - Vulnerability: Vulnerabilities in third-party email services or plugins can expose email content or grant unauthorized access to accounts.
   - Solution: Keep third-party services and plugins up to date and regularly audit and assess their security features.





















RESULT:
    The security vulnerabilities of e-mail application are analysed.
                   
                   
                    AD18712 - CYBER SECURITY LABORATORY

Pg.No:1       `		    Reg.No:2127200502xxx


